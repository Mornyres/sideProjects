#ifndef _WYT_CORE_H_
#define _WYT_CORE_H_

#include "integer.h"
#include "stdint.h"

/* todo: fat16 grab cluster synchro. constant read location in mem; may overwrite data; consider removal of card, corruption; eject button; */

/* INCLUDES & DEFINES*/

/* todo: organize these defines! */

// File status
#define FIL_AVAIL		0
#define FIL_OPEN		1
#define FIL_WPROTECT	2

// just a debug define to ignore unimplemented error handling
#define ERROR_CODE -1
#define OK 0

#define FAT_TYPE FAT16

#define FAT12 12
#define FAT16 16
#define FAT32 32

// https://en.m.wikipedia.org/wiki/Design_of_the_FAT_file_system#FAT_EOC
#define EOC 0xFFFF

// 11 chars for short filename standard
	// (8 base + 3 extension)
#define FILENAME_MAX 8+3
#define BPBSIZE 32+4

// general status codes
#define FILNAME_MATCH  0x0


// this should be only the filename, possibly with a slash in front
#define MAX_PATHLENGTH FILENAME_MAX + 1

#define MIN(x, y) (((x) < (y))?(x):(y))

#ifdef FAT_TYPE

// extended bpb for specific fat type
// for raw size: 54 + 8 - 36 base BPB
#if (FAT_TYPE == FAT16)
	#define E_BPBSIZE 0x36 + 8
#else
	// todo: other fat types
#endif

#endif	/* manually setting fat type for our purposes so it's always FAT16 */
// not supporting others



// these are the MASK values; i.e. bit position plus 1 
/* standardized */
enum DIRENTRY_ATTRIBUTES{
	READONLY = 0x1,
	HIDDEN = 0x02,
	SYSTEM = 0x04,
	VOL_LABEL = 0x08,
	SUBDIR = 0x10,
	ARCHIVE = 0x20,
	DEVICE = 0x40,
	RESERVED = 0x80
};


/* following 
http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html ]*/
enum FIL_FLAGS{
	READACCESS = 0X01,
	WRITEACCESS = 0X02,
	RDWR = 0X03,
	CREATE = 0X04,
	APPEND = 0X08
};

enum LSEEK_FLAGS{
	SEEK_SET = 0x01,
	SEEK_CUR = 0x02,
	SEEK_END = 0x03

};

/* following structs are physical data structures which correspond to FAT standards as per white paper*/

// basic boot sector values for FAT
typedef struct {

	
	/*
	type			name			offset
	*/	
	
	/* these 2 are actually part of BS (outside BPB) and will be more or less thrown away once gathered from the volume: */
	uint8_t 		BS_jmpBoot[3];  // 0
	uint8_t 		BS_OEMName[8];	// 3
	
	// often 512
	uint16_t 	    BPB_BytsPerSec;	// 11

	// allowed: 1, 2, 4... 128
	uint8_t			BPB_SecPerClus;	// 13


	uint16_t		BPB_RsvdSecCnt;	// 14


	uint8_t			BPB_NumFATs;	// 16
	
	/* For FAT12 and FAT16 volumes, this value should always specify a count that when multiplied by 32 results in an even multiple of BPB_BytsPerSec. For maximum compatibility, FAT16 volumes should use the value 512. */
	uint16_t		BPB_RootEntCnt;	// 17
	
	/* iff zero instead use offset at 0x20 */
	uint16_t		BPB_TotSec16;	// 19


	uint8_t			BPB_Media;		// 21


	uint16_t		BPB_FATSz16;	// 22

	/* below for DOS 3.31 BPB */

	uint16_t		BPB_SecPerTrk;	// 24
	uint16_t		BPB_NumHeads;	// 26
	uint32_t 		BPB_HiddSec;	// 28
	uint32_t 		BPB_TotSec32;	// 32
 
	uint8_t		extended_section[E_BPBSIZE];
 
} WYT_BPB_base_t;

// extended boot sector values for FAT16
// most notes sourced from FAT spec
typedef struct {
	
	// associate base/common attributes with this extension
	WYT_BPB_base_t* BPB_base;
	
	
	// offset: 36
	uint8_t		BS_DrvNum;
	
	// offset: 37
	uint8_t		BS_Reserved1;
	
	// offset: 38
	uint8_t		BS_BootSig;

	// offset: 39
	// << This ID is usually generated by simply combining the current date and time into a 32-bit value >>
	uint16_t 	BS_VolID[2]; 
	
	// offset: 43
	uint8_t		BS_VolLab[11];
	
	// offset: 54
	//<< One of the strings FAT12   FAT16   or FAT32 >>
	uint8_t		BS_FilSysType[8];
 
} WYT_BPB_16_t;

// extended boot sector values for FAT32
typedef struct {
	// associate base/common attributes with this extension
	WYT_BPB_base_t* BPB_base;
	
	uint8_t		table_size_32;
	uint16_t	extended_flags;
	uint16_t	fat_version;
	uint8_t		root_cluster;
	uint16_t	fat_info;
	uint16_t	backup_BS_sector;
	uint8_t 	BS_Reserved1[12];
	uint8_t		BS_DrvNum;
	uint8_t 	reserved_1;
	uint8_t		BS_BootSig;
	uint8_t 	volume_id;
	uint8_t		BS_VolLab[11];
	uint8_t		BS_FilSysType[8];
 
} WYT_BPB_32_t;


/* directory entries -- applies to files, directories themselves, subdirs */
typedef struct
{
	/* for now, shoving name and extension in one region */
	uint8_t		dirent_name[11];		// offset: 0x00 | region width: 11B	
		/* uint8_t dirent_name[8]		// offset: 0x00 | 8B */
		/* uint8_t dirent_extension[3]	// offset: 0x08 | 3B */

	uint8_t		dirent_attrib;			//	0x0B | 	1B
	
	/* for completeness, may as well. Might do error checking using this region at some point.*/
	uint8_t		dirent_reserved;		//	0x0C |	1B
	
	/* units of 10ms, values 0 to 199 allowed */
	uint8_t		dirent_createTimeFine;	// 	0x0D |	1B
	
	
	
	/* bits 15-11: Hours (0-23) | 10-5: Min (0-59) | 4-0: Secs/2 (0-29) */
	uint16_t	dirent_createTime;		// 	0x0E |	2B
	
	/* bits 15-9: Year (0 = 1980) | 8-5: Month (1-12) | 4-0: Day (1-31) */
	uint16_t	dirent_createDate;		//	0x10 | 2B

	/* bits 15-9: Year (0 = 1980) | 8-5: Month (1-12) | 4-0: Day (1-31) */
	uint16_t	dirent_accessDate;		//	0x12 | 2B
	
	/*  FAT12/16: Reserved
		FAT32: Highest 2 bytes of first dirent cluster */
	uint16_t	dirent_ClusterHi;		//	0x14 | 2B
	
	/* bits 15-11: Hours (0-23) | 10-5: Min (0-59) | 4-0: Secs/2 (0-29) */
	uint16_t	dirent_writeTime;		//	0x16 |	2B
	
	/* bits 15-9: Year (0 = 1980) | 8-5: Month (1-12) | 4-0: Day (1-31) */
	uint16_t	dirent_writeDate;		//	0x18 |	2B
	
	/*	FAT12/16: full 2 bytes of first dirent cluster
		FAT32: Lowest 2 bytes of first dirent cluster*/
	uint16_t	dirent_clusterLo;		// 	0x1A |	2B
	
	
	
	/* File/dir size if applicable(B) -- if volume label/subdir, must be 0*/
	uint32_t 	dirent_size;			// 	0x1C | 	4B
	
	
} WYT_DirEntry_t;	/* total size: 32B (FAT standard) */



/* some file info not included in base dir. entry standard is useful */
/* this is more or less unique to the end user -- functions really reference the corresponding dirent */
typedef struct {
	char fil_name[FILENAME_MAX];

	uint8_t fil_flags;		// optional nonstandard flags
	uint32_t fil_pointer;	// file pointer offset

	uint32_t fil_currentCluster;
	uint32_t fil_currentSector;

	WYT_DirEntry_t*		fil_activeDirentry;	// corresponding dirent to this file -- used for size, first cluster,

} WYT_File_t;

typedef struct {
	uint8_t		fs_type;
	uint8_t		fs_flags;
	uint8_t		fs_sectorsPerCluster;

	uint16_t	fs_bytesPerSector;
	uint16_t	fs_reservedSectors;

	uint32_t	fs_size;
	uint32_t 	fs_nClusters;

	uint32_t	fs_firstCluster;

	WYT_File_t*	fs_activeFile;	// may be useful in future
	WYT_File_t* fs_activeDirectory;

} WYT_FileSystem_t;

/**************************************/
/* FUNCTION PROTOTYPES */
/*	see func. definitions in core.c for further detail. */
/*************************************/

/* Current function format :
WYT_([fs]filesystem [fil]e | [dir]ectory)_function
	- camelCase for long function names
*/

uint8_t WYT_fs_init(void);

uint8_t WYT_fil_create(
	WYT_File_t* targetFile
	,const char* targetFilePath	/* the actual path of the file to open */);

uint8_t WYT_fil_open(
	WYT_File_t* targetFile /* the struct pointer to be associated with the file upon successful opening */
	,const char* targetFilePath	/* the actual path of the file to open */
	,uint8_t openFlags
);

uint8_t WYT_fil_write(
	WYT_File_t* targetFile
	,const void* inputBuffer
	,uint32_t inputSize
);

uint8_t WYT_fil_read(
	WYT_File_t* targetFile,
	void* outputBuffer,
	uint8_t outputSize
);

uint8_t WYT_fil_lseek(
	WYT_File_t* inputFile,
	uint32_t offset,
	uint8_t whence
);

uint8_t WYT_dir_nameCompare(const char* path, const char* dirent);

#endif 
/* _WYT_CORE_H_ */
